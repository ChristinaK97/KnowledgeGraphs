"""
UNION FIND
	 Για την υλοποίηση της δομής επιλέγεται η μέθοδος quick union.
	 Κάθε υποσέτ αναπαριστάται ως ένα δέντρο. Οι κόμβοι του δέντρου περιέχουν τα στοιχεία του υποσέτ
	 με το στοιχείο στη ρίζα του δέντρου να θεωρείται ο αντιπρόσωπος του υποσέτ.
	 Πχ για στοιχεία: 1,2,4,5
	 αρχικά ορίζονται τα υποσέτ  {1},{2},{4},{5}
	 δηλασή ο πίνακα parent {<1,-1>, <2,-1>,<4,-1>, <5,-1>}
	 η τιμή -1 δηλώνει ότι το στοιχείο είναι η ρίζα του δέντρου που ανήκει.
	 Αν εκτελεστούν οι λειτουργίες:

	 union(1,4) : parent {<1,-1>, <2,-1>, <4,1>, <5,-1>}
	 1 2 5                      άρα έχουμε τα σετ  {1,4},{2},{5}
	 |
	 4

	 union(5,2) : parent {<1,-1>, <2,5>, <4,1>, <5,-1>}
	 1  5                         άρα έχουμε τα σετ  {1,4}, {5,2}
	 |  |
	 4  2

	 union(4,5) : parent {<1,-1>, <2,5>, <4,1>, <5,1>}
	    1                         άρα έχουμε το σετ  {1,4,5,2}
	   / \
	  4   5
	      |
	      2

"""
class UnionFind:

	def __init__(self, nElements):
		self.nSets = nElements
		self.nInitSets = nElements
		self.parent = {i : -1 for i in range(self.nSets)}  # <int, int>

	def find(self, x):
		"""
		Προσδιορίζει σε ποια συνεκτική συνηστώσα (σε ποιο υποσετ) ανήκει το στοιχείο με id=x.
		Μπορεί να χρησιμοποιηθεί για να προσδιορίσει αν δύο στοιχεία ανήκουν στο ίδιο υποσετ.
		@param x: Το id ενός μυρμηγκιού
		@return Τον αντιπρόσωπο του υποσετ που ανήκει το x.
		"""
		if self.parent[x] == -1: # -1 : δηλώνει ότι το στοιχείο είναι η ρίζα του δέντρου που ανήκει
			return x
		else: # εξετάζει αναδρομικά το γονέα του στοιχείου x μέχρι να βρεί τη ρίζα του δέντρου που ανήκει.
			return self.find(self.parent[x])


	def union(self, x, y):
		"""
		Αν τα στοιχεία x και y δεν ανήκουν στο ίδιο υποσέτ, τότε η προσθήκη του ζευγους x,y δεν δημιουργεί
		κύκλο, άρα συμπεριλαμβάνεται στο MST και το υποσέτ που περιέχει το y ενώνεται με το υποσέτ που περιέχει το x
		και επιστρέφει true. Αλλιώς αν τα x και y ανήκουν στο ίδιο υποσέτ, τότε η  προσθήκη της ακμής x,y
		θα δημιουργούσε κύκλο στο γράφημα. Σε αυτή την περίπτωση επιστρέφει false.
		"""
		# print(f"union({x}, {y});")
		parX = self.find(x)  # ρίζα του δέντρου που ανήκει το x
		parY = self.find(y)  # ρίζα του δέντρου που ανήκει το y
		if parX != parY:	 # τα x και y δεν ανήκουν στο ίδιο υποσετ άρα ένωσε τα δύο υποσετ
			self.nSets -= 1
			self.parent[parY] = parX	# ως ρίζα του δέντρου y ορίζεται η ρίζα του δέντρου x
			return True					# Έγινε ένωση. Δεν δημιουργείται κύκλος
		return False					# δεν έγινε ένωση

	def getSets(self):
		sets = {i : [] for i in range(self.nInitSets)}
		for name in self.parent.keys():
			sets[self.find(name)].append(name)
		sets = [s for s in sets.values() if s]
		return sets


"""
uf = UnionFind(4)
uf.union(0, 1);
uf.union(0, 2);
uf.union(1, 3);
uf.union(2, 3);
print(uf.getSets())
"""
